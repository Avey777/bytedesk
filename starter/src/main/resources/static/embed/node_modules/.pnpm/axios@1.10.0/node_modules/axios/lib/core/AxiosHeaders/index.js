import i from "../../utils/index.js";
import S from "../../helpers/parseHeaders/index.js";
const h = Symbol("internals");
function y(r) {
  return r && String(r).trim().toLowerCase();
}
function m(r) {
  return r === !1 || r == null ? r : i.isArray(r) ? r.map(m) : String(r);
}
function A(r) {
  const t = /* @__PURE__ */ Object.create(null), e = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let s;
  for (; s = e.exec(r); )
    t[s[1]] = s[2];
  return t;
}
const k = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function g(r, t, e, s, n) {
  if (i.isFunction(s))
    return s.call(this, t, e);
  if (n && (t = e), !!i.isString(t)) {
    if (i.isString(s))
      return t.indexOf(s) !== -1;
    if (i.isRegExp(s))
      return s.test(t);
  }
}
function E(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, e, s) => e.toUpperCase() + s);
}
function j(r, t) {
  const e = i.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((s) => {
    Object.defineProperty(r, s + e, {
      value: function(n, o, f) {
        return this[s].call(this, t, n, o, f);
      },
      configurable: !0
    });
  });
}
class b {
  constructor(t) {
    t && this.set(t);
  }
  set(t, e, s) {
    const n = this;
    function o(c, l, a) {
      const u = y(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const p = i.findKey(n, u);
      (!p || n[p] === void 0 || a === !0 || a === void 0 && n[p] !== !1) && (n[p || l] = m(c));
    }
    const f = (c, l) => i.forEach(c, (a, u) => o(a, u, l));
    if (i.isPlainObject(t) || t instanceof this.constructor)
      f(t, e);
    else if (i.isString(t) && (t = t.trim()) && !k(t))
      f(S(t), e);
    else if (i.isObject(t) && i.isIterable(t)) {
      let c = {}, l, a;
      for (const u of t) {
        if (!i.isArray(u))
          throw TypeError("Object iterator must return a key-value pair");
        c[a = u[0]] = (l = c[a]) ? i.isArray(l) ? [...l, u[1]] : [l, u[1]] : u[1];
      }
      f(c, e);
    } else
      t != null && o(e, t, s);
    return this;
  }
  get(t, e) {
    if (t = y(t), t) {
      const s = i.findKey(this, t);
      if (s) {
        const n = this[s];
        if (!e)
          return n;
        if (e === !0)
          return A(n);
        if (i.isFunction(e))
          return e.call(this, n, s);
        if (i.isRegExp(e))
          return e.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, e) {
    if (t = y(t), t) {
      const s = i.findKey(this, t);
      return !!(s && this[s] !== void 0 && (!e || g(this, this[s], s, e)));
    }
    return !1;
  }
  delete(t, e) {
    const s = this;
    let n = !1;
    function o(f) {
      if (f = y(f), f) {
        const c = i.findKey(s, f);
        c && (!e || g(s, s[c], c, e)) && (delete s[c], n = !0);
      }
    }
    return i.isArray(t) ? t.forEach(o) : o(t), n;
  }
  clear(t) {
    const e = Object.keys(this);
    let s = e.length, n = !1;
    for (; s--; ) {
      const o = e[s];
      (!t || g(this, this[o], o, t, !0)) && (delete this[o], n = !0);
    }
    return n;
  }
  normalize(t) {
    const e = this, s = {};
    return i.forEach(this, (n, o) => {
      const f = i.findKey(s, o);
      if (f) {
        e[f] = m(n), delete e[o];
        return;
      }
      const c = t ? E(o) : String(o).trim();
      c !== o && delete e[o], e[c] = m(n), s[c] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const e = /* @__PURE__ */ Object.create(null);
    return i.forEach(this, (s, n) => {
      s != null && s !== !1 && (e[n] = t && i.isArray(s) ? s.join(", ") : s);
    }), e;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, e]) => t + ": " + e).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...e) {
    const s = new this(t);
    return e.forEach((n) => s.set(n)), s;
  }
  static accessor(t) {
    const s = (this[h] = this[h] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function o(f) {
      const c = y(f);
      s[c] || (j(n, f), s[c] = !0);
    }
    return i.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
b.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
i.reduceDescriptors(b.prototype, ({ value: r }, t) => {
  let e = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => r,
    set(s) {
      this[e] = s;
    }
  };
});
i.freezeMethods(b);
export {
  b as default
};
