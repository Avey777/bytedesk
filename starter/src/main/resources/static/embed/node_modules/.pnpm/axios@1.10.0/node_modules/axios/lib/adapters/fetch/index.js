import D from "../../platform/index/index.js";
import r from "../../utils/index.js";
import l from "../../core/AxiosError/index.js";
import H from "../../helpers/composeSignals/index.js";
import { trackStream as P } from "../../helpers/trackStream/index.js";
import K from "../../core/AxiosHeaders/index.js";
import { progressEventDecorator as A, progressEventReducer as O, asyncDecorator as _ } from "../../helpers/progressEventReducer/index.js";
import z from "../../helpers/resolveConfig/index.js";
import j from "../../core/settle/index.js";
const w = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", F = w && typeof ReadableStream == "function", I = w && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), N = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, J = F && N(() => {
  let e = !1;
  const t = new Request(D.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), B = 64 * 1024, T = F && N(() => r.isReadableStream(new Response("").body)), g = {
  stream: T && ((e) => e.body)
};
w && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !g[t] && (g[t] = r.isFunction(e[t]) ? (s) => s[t]() : (s, u) => {
      throw new l(`Response type '${t}' is not supported`, l.ERR_NOT_SUPPORT, u);
    });
  });
})(new Response());
const V = async (e) => {
  if (e == null)
    return 0;
  if (r.isBlob(e))
    return e.size;
  if (r.isSpecCompliantForm(e))
    return (await new Request(D.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (r.isArrayBufferView(e) || r.isArrayBuffer(e))
    return e.byteLength;
  if (r.isURLSearchParams(e) && (e = e + ""), r.isString(e))
    return (await I(e)).byteLength;
}, W = async (e, t) => {
  const s = r.toFiniteNumber(e.getContentLength());
  return s ?? V(t);
}, re = w && (async (e) => {
  let {
    url: t,
    method: s,
    data: u,
    signal: U,
    cancelToken: x,
    timeout: v,
    onDownloadProgress: R,
    onUploadProgress: b,
    responseType: n,
    headers: y,
    withCredentials: m = "same-origin",
    fetchOptions: E
  } = z(e);
  n = n ? (n + "").toLowerCase() : "text";
  let d = H([U, x && x.toAbortSignal()], v), f;
  const c = d && d.unsubscribe && (() => {
    d.unsubscribe();
  });
  let C;
  try {
    if (b && J && s !== "get" && s !== "head" && (C = await W(y, u)) !== 0) {
      let i = new Request(t, {
        method: "POST",
        body: u,
        duplex: "half"
      }), p;
      if (r.isFormData(u) && (p = i.headers.get("content-type")) && y.setContentType(p), i.body) {
        const [S, h] = A(
          C,
          O(_(b))
        );
        u = P(i.body, B, S, h);
      }
    }
    r.isString(m) || (m = m ? "include" : "omit");
    const o = "credentials" in Request.prototype;
    f = new Request(t, {
      ...E,
      signal: d,
      method: s.toUpperCase(),
      headers: y.normalize().toJSON(),
      body: u,
      duplex: "half",
      credentials: o ? m : void 0
    });
    let a = await fetch(f, E);
    const q = T && (n === "stream" || n === "response");
    if (T && (R || q && c)) {
      const i = {};
      ["status", "statusText", "headers"].forEach((L) => {
        i[L] = a[L];
      });
      const p = r.toFiniteNumber(a.headers.get("content-length")), [S, h] = R && A(
        p,
        O(_(R), !0)
      ) || [];
      a = new Response(
        P(a.body, B, S, () => {
          h && h(), c && c();
        }),
        i
      );
    }
    n = n || "text";
    let k = await g[r.findKey(g, n) || "text"](a, e);
    return !q && c && c(), await new Promise((i, p) => {
      j(i, p, {
        data: k,
        headers: K.from(a.headers),
        status: a.status,
        statusText: a.statusText,
        config: e,
        request: f
      });
    });
  } catch (o) {
    throw c && c(), o && o.name === "TypeError" && /Load failed|fetch/i.test(o.message) ? Object.assign(
      new l("Network Error", l.ERR_NETWORK, e, f),
      {
        cause: o.cause || o
      }
    ) : l.from(o, o && o.code, e, f);
  }
});
export {
  re as default
};
